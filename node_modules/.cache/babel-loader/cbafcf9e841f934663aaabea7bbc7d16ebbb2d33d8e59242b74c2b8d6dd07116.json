{"ast":null,"code":"var _jsxFileName = \"/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx\",\n  _s = $RefreshSig$();\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { useCallback, useRef, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\nimport { Form, Input } from 'antd';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Search = () => {\n  _s();\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector(state => state.search.searchValue);\n  const dispatch = useDispatch();\n  const [searchText, setSearchText] = useState('');\n\n  // const makeDebounce = (value) => {\n  //   debounce(\n  //     (value) => {\n  //       console.log('debounce', value);\n  //       dispatch(setSearchValue(value));\n  //     },\n  //     1000,\n  //   )()\n  //   };\n\n  const makeDebounce = useCallback(debounce(value => {\n    console.log('debounce', value);\n    dispatch(setSearchValue(value));\n  }, 1000), []);\n  const onChangeInput = e => {\n    setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n  /**------------------------------------------------------------------------------------------------\n   * !                                          CLEAR INPUT logic\n   *   При нажатии на крестик нам нужно очищать инпут setSearchText(''), а затем оставлять фокус на инпуте.\n   *   Если мы сделаем это через\n   *   const input = document.querySelector(\"input\");\n   *   input.focus()\n   *   То все будет работать, однако мы управляем состоянием инпута не через реакт, чего делать нельзя.\n   *   Чтобы сделать это правильно, воспользуемся хуком useRef (const inputRef = useRef(), который\n   *   возвращает ссылку на переменную или элемент (и она не меняется при ререндере). В нашем инпуте\n   *   добавим ref=inputRef. И теперь сделаем фокус на инпуте inputRef.current.focus().\n   *   Так же при очистке инпута, мы должны передать в стор пустой searchValue (сделаем это моментально\n   *   без debounce)\n   *------------------------------------------------------------------------------------------------**/\n  const inputRef = useRef(null);\n  const clearInput = () => {\n    var _inputRef$current;\n    setSearchText('');\n    //  const input = document.querySelector(\"input\");\n    //  input.focus()\n    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();\n    dispatch(setSearchValue(''));\n  };\n  /*------------------------------------------ END OF CLEAR INPUT ------------------------------------------*/\n\n  // console.log('searchValue', searchValue);\n\n  const [form] = Form.useForm();\n  const nameValue = Form.useWatch('value', form);\n  const makeSeach = e => {\n    console.log(e);\n    // dispatch(setSearchValue(value));\n  };\n  console.log(nameValue);\n  return /*#__PURE__*/_jsxDEV(Form, {\n    form: form,\n    layout: \"vertical\",\n    autoComplete: \"off\",\n    children: /*#__PURE__*/_jsxDEV(Form.Item, {\n      validateDebounce: 1000,\n      children: /*#__PURE__*/_jsxDEV(Input, {\n        onChange: makeSeach,\n        placeholder: \"\\u041F\\u043E\\u0438\\u0441\\u043A...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 112,\n    columnNumber: 5\n  }, this)\n\n  // <div className={s.search__div}>\n  //   <input\n  //     ref={inputRef}\n  //     className={s.search__input}\n  //     placeholder=\"поиск\"\n  //     onChange={onChangeInput}\n  //     value={searchText /*searchValue*/}\n  //   />\n  //   {searchText && <BsXLg className={s.close__icon} onClick={() => clearInput()} />}\n  // </div>\n  ;\n};\n_s(Search, \"Az9gbM71Tf79vX5gcrw3EkSWEmM=\", false, function () {\n  return [useSelector, useDispatch, Form.useForm, Form.useWatch];\n});\n_c = Search;\nvar _c;\n$RefreshReg$(_c, \"Search\");","map":{"version":3,"names":["setSearchValue","useSelector","useDispatch","useCallback","useRef","useState","debounce","Form","Input","jsxDEV","_jsxDEV","Search","_s","searchValue","state","search","dispatch","searchText","setSearchText","makeDebounce","value","console","log","onChangeInput","e","target","inputRef","clearInput","_inputRef$current","current","focus","form","useForm","nameValue","useWatch","makeSeach","layout","autoComplete","children","Item","validateDebounce","onChange","placeholder","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx"],"sourcesContent":["import s from './Search.module.scss';\nimport { BsXLg } from 'react-icons/bs';\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { ChangeEvent, useCallback, useRef, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\nimport { Form, Input } from 'antd';\n\nexport const Search = () => {\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector((state: any) => state.search.searchValue);\n  const dispatch = useDispatch();\n\n  const [searchText, setSearchText] = useState('');\n\n  // const makeDebounce = (value) => {\n  //   debounce(\n  //     (value) => {\n  //       console.log('debounce', value);\n  //       dispatch(setSearchValue(value));\n  //     },\n  //     1000,\n  //   )()\n  //   };\n\n  const makeDebounce = useCallback(\n    debounce((value: string) => {\n      console.log('debounce', value);\n      dispatch(setSearchValue(value));\n    }, 1000),\n    [],\n  );\n\n  const onChangeInput = (e: ChangeEvent<HTMLInputElement>) => {\n    setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n  /**------------------------------------------------------------------------------------------------\n   * !                                          CLEAR INPUT logic\n   *   При нажатии на крестик нам нужно очищать инпут setSearchText(''), а затем оставлять фокус на инпуте.\n   *   Если мы сделаем это через\n   *   const input = document.querySelector(\"input\");\n   *   input.focus()\n   *   То все будет работать, однако мы управляем состоянием инпута не через реакт, чего делать нельзя.\n   *   Чтобы сделать это правильно, воспользуемся хуком useRef (const inputRef = useRef(), который\n   *   возвращает ссылку на переменную или элемент (и она не меняется при ререндере). В нашем инпуте\n   *   добавим ref=inputRef. И теперь сделаем фокус на инпуте inputRef.current.focus().\n   *   Так же при очистке инпута, мы должны передать в стор пустой searchValue (сделаем это моментально\n   *   без debounce)\n   *------------------------------------------------------------------------------------------------**/\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const clearInput = () => {\n    setSearchText('');\n    //  const input = document.querySelector(\"input\");\n    //  input.focus()\n    inputRef.current?.focus();\n    dispatch(setSearchValue(''));\n  };\n  /*------------------------------------------ END OF CLEAR INPUT ------------------------------------------*/\n\n  // console.log('searchValue', searchValue);\n\n  const [form] = Form.useForm<{ value: string }>();\n  const nameValue = Form.useWatch('value', form);\n\n  const makeSeach = (e: React.ChangeEventHandler<HTMLInputElement>) => {\n    console.log(e)\n    // dispatch(setSearchValue(value));\n  };\n\n  console.log(nameValue)\n\n  return (\n    <Form form={form} layout=\"vertical\" autoComplete=\"off\">\n      <Form.Item validateDebounce={1000}>\n        <Input  onChange={makeSeach} placeholder=\"Поиск...\"  />\n      </Form.Item>\n    </Form>\n\n    // <div className={s.search__div}>\n    //   <input\n    //     ref={inputRef}\n    //     className={s.search__input}\n    //     placeholder=\"поиск\"\n    //     onChange={onChangeInput}\n    //     value={searchText /*searchValue*/}\n    //   />\n    //   {searchText && <BsXLg className={s.close__icon} onClick={() => clearInput()} />}\n    // </div>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}