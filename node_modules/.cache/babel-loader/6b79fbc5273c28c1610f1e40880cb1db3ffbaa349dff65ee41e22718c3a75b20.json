{"ast":null,"code":"var _jsxFileName = \"/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx\",\n  _s = $RefreshSig$();\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { useCallback, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\nimport { Form, Input } from 'antd';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Search = () => {\n  _s();\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector(state => state.search.searchValue);\n  const dispatch = useDispatch();\n  const [searchText, setSearchText] = useState('');\n  const makeDebounce = useCallback(debounce(value => {\n    // console.log('debounce', value);\n    dispatch(setSearchValue(value));\n  }, 1000), []);\n  const onChangeInput = e => {\n    // setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n  return /*#__PURE__*/_jsxDEV(Form, {\n    layout: \"vertical\",\n    autoComplete: \"off\",\n    children: /*#__PURE__*/_jsxDEV(Form.Item, {\n      children: /*#__PURE__*/_jsxDEV(Input, {\n        allowClear: true,\n        onChange: onChangeInput,\n        placeholder: \"\\u041F\\u043E\\u0438\\u0441\\u043A...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 70,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 68,\n    columnNumber: 5\n  }, this);\n};\n\n// <div className={s.search__div}>\n//   <input\n//     ref={inputRef}\n//     className={s.search__input}\n//     placeholder=\"поиск\"\n//     onChange={onChangeInput}\n//     value={searchText /*searchValue*/}\n//   />\n//   {searchText && <BsXLg className={s.close__icon} onClick={() => clearInput()} />}\n// </div>\n_s(Search, \"xDW2i15yye4EIVV3B0oI4wuNF3U=\", false, function () {\n  return [useSelector, useDispatch];\n});\n_c = Search;\nvar _c;\n$RefreshReg$(_c, \"Search\");","map":{"version":3,"names":["setSearchValue","useSelector","useDispatch","useCallback","useState","debounce","Form","Input","jsxDEV","_jsxDEV","Search","_s","searchValue","state","search","dispatch","searchText","setSearchText","makeDebounce","value","onChangeInput","e","target","layout","autoComplete","children","Item","allowClear","onChange","placeholder","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx"],"sourcesContent":["import s from './Search.module.scss';\nimport { BsXLg } from 'react-icons/bs';\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { ChangeEvent, useCallback, useRef, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\nimport { Form, Input } from 'antd';\n\nexport const Search = () => {\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector((state: any) => state.search.searchValue);\n  const dispatch = useDispatch();\n\n  const [searchText, setSearchText] = useState('');\n\n\n  const makeDebounce = useCallback(\n    debounce((value: string) => {\n      // console.log('debounce', value);\n      dispatch(setSearchValue(value));\n    }, 1000),\n    [],\n  );\n\n  const onChangeInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    // setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n\n  return (\n    <Form layout=\"vertical\" autoComplete=\"off\">\n      <Form.Item>\n        <Input  allowClear onChange={onChangeInput} placeholder=\"Поиск...\"  />\n      </Form.Item>\n    </Form>\n  );\n};\n\n\n    // <div className={s.search__div}>\n    //   <input\n    //     ref={inputRef}\n    //     className={s.search__input}\n    //     placeholder=\"поиск\"\n    //     onChange={onChangeInput}\n    //     value={searchText /*searchValue*/}\n    //   />\n    //   {searchText && <BsXLg className={s.close__icon} onClick={() => clearInput()} />}\n    // </div>"],"mappings":";;AAEA,SAASA,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,WAAW,EAAEC,WAAW,QAAQ,aAAa;AACtD,SAAsBC,WAAW,EAAUC,QAAQ,QAAQ,OAAO;AAClE;AACA,OAAOC,QAAQ,MAAM,iBAAiB;AACtC,SAASC,IAAI,EAAEC,KAAK,QAAQ,MAAM;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEnC,OAAO,MAAMC,MAAM,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,WAAW,GAAGX,WAAW,CAAEY,KAAU,IAAKA,KAAK,CAACC,MAAM,CAACF,WAAW,CAAC;EACzE,MAAMG,QAAQ,GAAGb,WAAW,CAAC,CAAC;EAE9B,MAAM,CAACc,UAAU,EAAEC,aAAa,CAAC,GAAGb,QAAQ,CAAC,EAAE,CAAC;EAGhD,MAAMc,YAAY,GAAGf,WAAW,CAC9BE,QAAQ,CAAEc,KAAa,IAAK;IAC1B;IACAJ,QAAQ,CAACf,cAAc,CAACmB,KAAK,CAAC,CAAC;EACjC,CAAC,EAAE,IAAI,CAAC,EACR,EACF,CAAC;EAED,MAAMC,aAAa,GAAIC,CAAsC,IAAK;IAChE;IACAH,YAAY,CAACG,CAAC,CAACC,MAAM,CAACH,KAAK,CAAC;EAC9B,CAAC;EACD;;EAGA,oBACEV,OAAA,CAACH,IAAI;IAACiB,MAAM,EAAC,UAAU;IAACC,YAAY,EAAC,KAAK;IAAAC,QAAA,eACxChB,OAAA,CAACH,IAAI,CAACoB,IAAI;MAAAD,QAAA,eACRhB,OAAA,CAACF,KAAK;QAAEoB,UAAU;QAACC,QAAQ,EAAER,aAAc;QAACS,WAAW,EAAC;MAAU;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC7D;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACR,CAAC;AAEX,CAAC;;AAGG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAAtB,EAAA,CA5ESD,MAAM;EAAA,QAoCGT,WAAW,EACdC,WAAW;AAAA;AAAAgC,EAAA,GArCjBxB,MAAM;AAAA,IAAAwB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}