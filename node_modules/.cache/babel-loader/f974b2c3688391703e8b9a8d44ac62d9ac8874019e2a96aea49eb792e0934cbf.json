{"ast":null,"code":"var _jsxFileName = \"/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx\",\n  _s = $RefreshSig$();\nimport s from './Search.module.scss';\nimport { BsXLg } from 'react-icons/bs';\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { useCallback, useRef, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Search = () => {\n  _s();\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector(state => state.search.searchValue);\n  const dispatch = useDispatch();\n  const [searchText, setSearchText] = useState('');\n\n  // const makeDebounce = (value) => {\n  //   debounce(\n  //     (value) => {\n  //       console.log('debounce', value);\n  //       dispatch(setSearchValue(value));\n  //     },\n  //     1000,\n  //   )()\n  //   };\n\n  const makeDebounce = useCallback(debounce(value => {\n    console.log('debounce', value);\n    dispatch(setSearchValue(value));\n  }, 1000), []);\n  const onChangeInput = e => {\n    setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n  /**------------------------------------------------------------------------------------------------\n   * !                                          CLEAR INPUT logic\n   *   При нажатии на крестик нам нужно очищать инпут setSearchText(''), а затем оставлять фокус на инпуте.\n   *   Если мы сделаем это через\n   *   const input = document.querySelector(\"input\");\n   *   input.focus()\n   *   То все будет работать, однако мы управляем состоянием инпута не через реакт, чего делать нельзя.\n   *   Чтобы сделать это правильно, воспользуемся хуком useRef (const inputRef = useRef(), который\n   *   возвращает ссылку на переменную или элемент (и она не меняется при ререндере). В нашем инпуте\n   *   добавим ref=inputRef. И теперь сделаем фокус на инпуте inputRef.current.focus().\n   *   Так же при очистке инпута, мы должны передать в стор пустой searchValue (сделаем это моментально\n   *   без debounce)\n   *------------------------------------------------------------------------------------------------**/\n  const inputRef = useRef(null);\n  const clearInput = () => {\n    var _inputRef$current;\n    setSearchText('');\n    //  const input = document.querySelector(\"input\");\n    //  input.focus()\n    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();\n    dispatch(setSearchValue(''));\n  };\n  /*------------------------------------------ END OF CLEAR INPUT ------------------------------------------*/\n\n  // console.log('searchValue', searchValue);\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: s.search__div,\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      ref: inputRef,\n      className: s.search__input,\n      placeholder: \"\\u043F\\u043E\\u0438\\u0441\\u043A\",\n      onChange: onChangeInput,\n      value: searchText /*searchValue*/\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 7\n    }, this), searchText && /*#__PURE__*/_jsxDEV(BsXLg, {\n      className: s.close__icon,\n      onClick: () => clearInput()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 22\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 5\n  }, this);\n};\n_s(Search, \"vjqs8zRNx3VRHsuWUjS4z1hRKfU=\", false, function () {\n  return [useSelector, useDispatch];\n});\n_c = Search;\nvar _c;\n$RefreshReg$(_c, \"Search\");","map":{"version":3,"names":["s","BsXLg","setSearchValue","useSelector","useDispatch","useCallback","useRef","useState","debounce","jsxDEV","_jsxDEV","Search","_s","searchValue","state","search","dispatch","searchText","setSearchText","makeDebounce","value","console","log","onChangeInput","e","target","inputRef","clearInput","_inputRef$current","current","focus","className","search__div","children","ref","search__input","placeholder","onChange","fileName","_jsxFileName","lineNumber","columnNumber","close__icon","onClick","_c","$RefreshReg$"],"sources":["/home/artem/github_space/pizza_antd/pizza_deco_antd/src/components/Search/Search.tsx"],"sourcesContent":["import s from './Search.module.scss';\nimport { BsXLg } from 'react-icons/bs';\nimport { setSearchValue } from '../../redux/slices/searchSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { ChangeEvent, useCallback, useRef, useState } from 'react';\n//@ts-ignore\nimport debounce from 'lodash.debounce';\n\nexport const Search = () => {\n  /**------------------------------------------------------------------------------------------------\n   * !                                          DEBOUNCE logic\n   *   Селектим searchValue из стора, при изменении этой переменной отправляется запрос на сервер (она в useEffect)\n   *   Т.к. мы не хотим отправлять новый запрос на сервер при каждом изменении в инпуте, то мы не можем использовать\n   *   searchValue в качестве value для инпута\n   *   Вместо этого мы создаем локальный стейт (searchtext) и передаем его в качестве value для инпута\n   *   Затем создаем функцию onChangeInput, которая должна менять текст в инпуте через searchtext\n   *   и через определенный лаг передавать то, что в инпуте(searchtext) в searchValue, и тогда новый запрос\n   *   на сервер отправляется.\n   *   Чтобы реализовать данный лаг, воспользуемся Debounce'ом из лодэша.\n   *   Т.к. на каждый ререндер функционального компонениа реакт выдялает разные места в памяти, это означает,\n   *   что функция makeDebounce при каждом ререндере будет менять свое место в памяти и соответственно\n   *   вызываться каждый раз заново(это приводит к тому, что при каждом рендере вызывается по сути новый\n   *   debounce и отрабаотывает, а если это была бы одна и та же функция в памяти, то debounce\n   *   запомнил бы, что уже отрабатывал и не выполнял dispatch, то есть в наешм случае мы говорим, что debounce\n   *   зависит от перерендеров (все отсальные переменные изменяются, и makeDebounce узнает об этом ввиду\n   *   обращения к лексической области видимости (получается ваерхней, тк там уже из-за рендера все значения поменялись,\n   *   makeDebounce ищет на уровне выше переменные при каждом ререндере и на каждом ререндере у них новые значения,\n   *   поэтому makeDebounce знает о новых значениях при каждом ререндере).\n   *   Однако сам makeDebounce остается при кажддом рендере одной и той же функцией в памяти и происходит\n   *   ситуация, когда makeDebounce сам по себе не зависит он ререндеров. То есть при каждом ререндере при том,\n   *   что все вокруг меняется, makeDebounce остается той же функцией, которая никак от ререндеров не\n   *   зависит, но все вокруг makeDebounce зависит от ререндеров и меняет свое значение, в то время как для\n   *   makeDebounce он остается неизменяемой функцией в то время, как все вокруг него почему-то меняется\n   *   (и меняются даже переменные, значения которых принимает makeDebounce). Именно из-за того, что эти\n   *   переменные меняются, а makeDebounce нет, то debounce может нормально работать (делать задержку при изменении\n   *   value).\n   *   Поэтому используем useCallback, который вернет неизменяемую функцию, и в массив зависимостей ничего не\n   *   передадим, тк нам нужно, чтобы makeDebounce создался и потом не изменялся.\n   *\n   *\n   *   То есть в onChangeInput меняется локальный стейт (который в инпут setSearchText(e.target.value), а\n   *   потом в  makeDebounce передаем e.target.value, (теперь dispatch(setSearchValue(value)) будет вызываться только\n   *   после задержки)\n   *------------------------------------------------------------------------------------------------**/\n  const searchValue = useSelector((state: any) => state.search.searchValue);\n  const dispatch = useDispatch();\n\n  const [searchText, setSearchText] = useState('');\n\n  // const makeDebounce = (value) => {\n  //   debounce(\n  //     (value) => {\n  //       console.log('debounce', value);\n  //       dispatch(setSearchValue(value));\n  //     },\n  //     1000,\n  //   )()\n  //   };\n\n  const makeDebounce = useCallback(\n    debounce((value: string) => {\n      console.log('debounce', value);\n      dispatch(setSearchValue(value));\n    }, 1000),\n    [],\n  );\n\n  const onChangeInput = (e: ChangeEvent<HTMLInputElement>) => {\n    setSearchText(e.target.value);\n    makeDebounce(e.target.value);\n  };\n  /*------------------------------------------ END OF DEBOUNCE ------------------------------------------*/\n\n  /**------------------------------------------------------------------------------------------------\n   * !                                          CLEAR INPUT logic\n   *   При нажатии на крестик нам нужно очищать инпут setSearchText(''), а затем оставлять фокус на инпуте.\n   *   Если мы сделаем это через\n   *   const input = document.querySelector(\"input\");\n   *   input.focus()\n   *   То все будет работать, однако мы управляем состоянием инпута не через реакт, чего делать нельзя.\n   *   Чтобы сделать это правильно, воспользуемся хуком useRef (const inputRef = useRef(), который\n   *   возвращает ссылку на переменную или элемент (и она не меняется при ререндере). В нашем инпуте\n   *   добавим ref=inputRef. И теперь сделаем фокус на инпуте inputRef.current.focus().\n   *   Так же при очистке инпута, мы должны передать в стор пустой searchValue (сделаем это моментально\n   *   без debounce)\n   *------------------------------------------------------------------------------------------------**/\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const clearInput = () => {\n    setSearchText('');\n    //  const input = document.querySelector(\"input\");\n    //  input.focus()\n    inputRef.current?.focus();\n    dispatch(setSearchValue(''));\n  };\n  /*------------------------------------------ END OF CLEAR INPUT ------------------------------------------*/\n\n  // console.log('searchValue', searchValue);\n\n  return (\n    <div className={s.search__div}>\n      <input\n        ref={inputRef}\n        className={s.search__input}\n        placeholder=\"поиск\"\n        onChange={onChangeInput}\n        value={searchText /*searchValue*/}\n      />\n      {searchText && <BsXLg className={s.close__icon} onClick={() => clearInput()} />}\n    </div>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}